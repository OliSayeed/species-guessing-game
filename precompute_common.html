<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Precompute Common Names (GBIF)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root{--line:#e5e7eb;--ink:#111;--muted:#666;}
  body{font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:24px;color:var(--ink)}
  h1{margin:0 0 6px}
  .muted{color:var(--muted)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:12px 0}
  button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:#fff;cursor:pointer}
  button:hover{background:#f3f4f6}
  progress{width:360px;height:10px}
  pre{background:#fff;border:1px solid var(--line);border-radius:10px;padding:10px;max-height:280px;overflow:auto}
  .ok{color:#0a7d25;font-weight:600}
  .warn{color:#a60d0d;font-weight:600}
</style>
</head>
<body>
<h1>Precompute Common Names</h1>
<p class="muted">Reads <code>extracted_species.txt</code>, asks GBIF for English vernacular names, and downloads <code>common_names.json</code>.</p>

<div class="row">
  <label>Species text file:
    <input id="file" type="file" accept=".txt">
  </label>
  <button id="start">Start</button>
</div>

<div class="row">
  <span>Progress:</span><progress id="prog" value="0" max="1"></progress>
  <span id="status" class="muted">idle</span>
</div>

<pre id="log"></pre>

<script>
const GBIF_MATCH = "https://api.gbif.org/v1/species/match";              // ?name=Genus%20species
const GBIF_VERN  = (key)=>`https://api.gbif.org/v1/species/${key}/vernacularNames?limit=200&language=en`;

const statusEl = document.getElementById("status");
const logEl = document.getElementById("log");
const prog = document.getElementById("prog");
function setStatus(s){ statusEl.textContent = s; }
function log(m){ logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; }

function saveJSON(obj, name){
  const blob = new Blob([JSON.stringify(obj)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

async function fetchJSON(url){
  const ctrl = new AbortController();
  const t = setTimeout(()=>ctrl.abort(), 12000);
  try{
    const r = await fetch(url, {signal: ctrl.signal, cache:"no-store"});
    if(!r.ok) throw new Error("HTTP "+r.status);
    return await r.json();
  } finally { clearTimeout(t); }
}

function parseLines(text){
  const genus = /[A-Z][a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
  const epithet = /(?:×\s*)?[a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
  const re = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
  const seen = new Set();
  return text.split(/\r?\n/)
    .map(s=>s.trim()).filter(Boolean)
    .filter(s=>re.test(s))
    .filter(s=>{ const k=s.toLowerCase(); if(seen.has(k)) return false; seen.add(k); return true; });
}

// choose the “best” English common name from GBIF vernaculars
function pickBestCommon(rows){
  if (!rows || !rows.length) return null;
  // prefer those flagged preferred/accepted; else shortest nice name
  const preferred = rows.filter(r => r.language==="eng" || r.language==="en" || r.language==="en_US" || r.language==="en_GB")
                        .filter(r => r.preferred || r.source==="Catalogue of Life" || r.source==="GBIF Backbone Taxonomy");
  const pool = preferred.length ? preferred : rows;
  // strip weird punctuation, pick shortest reasonable
  const cleaned = pool.map(r => (r.vernacularName||"").trim()).filter(Boolean);
  if (!cleaned.length) return null;
  cleaned.sort((a,b)=> a.length - b.length);
  return cleaned[0];
}

async function run(){
  const file = document.getElementById("file").files?.[0];
  if(!file){ alert("Choose extracted_species.txt"); return; }
  const text = await file.text();
  const names = parseLines(text);
  log(`Loaded ${names.length} scientific names`);

  const entries = []; // {sci, common|null}
  const name_to_common = {}; // lower -> common

  prog.value = 0; prog.max = names.length;

  // throttle: GBIF is pretty ok, but we’ll be polite (~6–8 req/s)
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  let success = 0, withCommon = 0;

  for (let i=0;i<names.length;i++){
    const sci = names[i];
    setStatus(`Matching ${i+1}/${names.length}`);
    try{
      const m = await fetchJSON(`${GBIF_MATCH}?name=${encodeURIComponent(sci)}`);
      if (!m || !m.usageKey){ entries.push({sci, common:null}); prog.value=i+1; await sleep(80); continue; }
      success++;

      const vj = await fetchJSON(GBIF_VERN(m.usageKey));
      const common = pickBestCommon(vj?.results||[]);
      entries.push({sci, common: common || null});
      if (common){
        withCommon++;
        name_to_common[sci.toLowerCase()] = common;
        name_to_common[common.toLowerCase()] = common; // allow direct lookup by common later
      }
    } catch(e){
      entries.push({sci, common:null});
    }
    prog.value = i+1;
    // light throttle
    await sleep(80);
    if ((i % 25)===0) await sleep(200);
  }

  log(`GBIF matched ${success}/${names.length}`);
  log(`Common names found for ${withCommon}/${names.length}`);
  setStatus("Saving…");
  const payload = { version:1, entries, name_to_common };
  saveJSON(payload, "common_names.json");
  setStatus("Done ✅");
}

document.getElementById("start").onclick = ()=>run().catch(e=>{
  setStatus("Error"); log("ERROR: "+e.message+"\n"+String(e.stack||""));
});
</script>
</body>
</html>
