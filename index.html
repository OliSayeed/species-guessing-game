<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Species Guessing Game — Partial Tree (Fast)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root { --card:#fff; --ink:#111; --muted:#666; --line:#e5e7eb; --good:#0a7d25; --bad:#a60d0d; }
    html,body{margin:0;padding:0;background:#fafafa;color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:1040px;margin:24px auto;padding:0 16px;}
    h1{margin:0 0 6px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{flex:1;min-width:280px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:16px}
    button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:white;cursor:pointer}
    button:hover{background:#f3f4f6}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#fff}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .good{color:var(--good);font-weight:700}
    .bad{color:var(--bad);font-weight:700}
    .small{font-size:14px}
    .section{margin-top:16px}
    .footer{margin-top:28px;color:var(--muted);font-size:14px}
    .viswrap{background:#fff;border:1px solid var(--line);border-radius:14px;overflow:hidden}
    svg{display:block;width:100%;height:520px;background:#fff;touch-action:none}
    .link{fill:none;stroke:#cbd5e1;stroke-width:1.2px}
    .leaf text{font-size:13px;dominant-baseline:middle}
    .leaf .label{fill:#111}
    .leaf .label.target{font-weight:700}
    .leaf .hint{fill:#666;font-size:12px}
    .tooltip{position:fixed;pointer-events:none;background:#111;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .12s ease;}
    .busy{opacity:.6}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Species Guessing Game</h1>
  <p class="muted">We reveal just the part of the tree needed to compare your guesses with the secret target. Leaves are your guesses; the target is <strong>?</strong>. The view auto-zooms to the relevant clade.</p>

  <div class="row section">
    <button id="newgame">New game</button>
    <span id="turns" class="pill">turns: 0</span>
    <span id="pool" class="pill small">pool: …</span>
    <span id="hint" class="pill small"></span>
    <span id="net" class="pill small">idle</span>
  </div>

  <div class="row section">
    <input id="guess" type="text" list="namelist" placeholder="Type a scientific name (e.g., Opisthocomus hoazin)" />
    <datalist id="namelist"></datalist>
    <button id="submit">Guess</button>
  </div>

  <div class="viswrap section">
    <svg id="tree"></svg>
  </div>

  <div id="status" class="card section" style="display:none;"></div>

  <div class="footer">APIs: OpenTree (TNRS + induced subtree) & OneZoom (vernaculars). Pure client-side.</div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
/* --------------------------
   Config & Endpoints
--------------------------- */
const OT_BASE = "https://api.opentreeoflife.org/v3";
const TNRS_URL = `${OT_BASE}/tnrs/match_names`;
const INDUCED_URL = `${OT_BASE}/tree_of_life/induced_subtree`;
const OZ_VERNACULAR_URL = "https://api.onezoom.org/vernacular_names.json"; // ?ott=<id>&lang=en
const TXT_PATH = "extracted_species.txt"; // same folder as index.html

// Timeouts + retries
const FETCH_TIMEOUT_MS = 9000;
const RETRIES = 2;

/* --------------------------
   Net helpers with timeout/cache
--------------------------- */
const NET = document.getElementById("net");
function setNet(s){ NET.textContent = s; }

async function fetchJSON(url, opts = {}, bodyObj = null){
  const attempt = async () => {
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), FETCH_TIMEOUT_MS);
    try{
      const resp = await fetch(url, {
        method: bodyObj ? "POST" : (opts.method || "GET"),
        headers: bodyObj ? {"Content-Type":"application/json", ...(opts.headers||{})} : (opts.headers||{}),
        body: bodyObj ? JSON.stringify(bodyObj) : (opts.body || undefined),
        signal: ctrl.signal,
        cache: "no-store",
        mode: "cors",
        keepalive: false,
      });
      if(!resp.ok) throw new Error("HTTP "+resp.status);
      return await resp.json();
    } finally {
      clearTimeout(t);
    }
  };
  let lastErr;
  for(let k=0;k<=RETRIES;k++){
    try{ return await attempt(); }catch(e){ lastErr = e; }
  }
  throw lastErr;
}

/* --------------------------
   State
--------------------------- */
let LIST = [];           // [{sci}]
let TARGET = null;       // {sci, ott, common}
let GUESSES = [];        // [{sci, ott, common}]
let turns = 0;

// Caches
const TNRS_CACHE = new Map();          // nameLower -> {ott,sci}
const VERN_CACHE = new Map();          // ott -> common name or null
const OTT2SCI = new Map();             // ott -> sci (from TNRS resolutions of target/guesses)
const OTT2COMMON = new Map();          // ott -> common (lazy)

function el(id){ return document.getElementById(id); }
function setTurns(n){ turns = n; el("turns").textContent = `turns: ${turns}`; }
function setPool(n){ el("pool").textContent = `pool: ${n}`; }
function setHint(t){ el("hint").textContent = t || ""; }

/* --------------------------
   Load list & datalist
--------------------------- */
async function loadTxtList(){
  try{
    const r = await fetch(TXT_PATH, {cache:"no-store"});
    if(!r.ok) throw new Error("missing list");
    const text = await r.text();
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const genus = /[A-Z][a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
    const epithet = /(?:×\s*)?[a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
    const re = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
    const seen = new Set();
    LIST = lines.filter(s=>re.test(s)).filter(s=>{
      const k=s.toLowerCase(); if(seen.has(k)) return false; seen.add(k); return true;
    }).map(s=>({sci:s}));
    setPool(LIST.length);
    const dl = el("namelist");
    for(const s of LIST.slice(0,1500)){ const o=document.createElement("option"); o.value=s.sci; dl.appendChild(o); }
  } catch { setPool(0); }
}

/* --------------------------
   OpenTree / OneZoom helpers (cached)
--------------------------- */
async function tnrsResolve(name){
  const key = name.toLowerCase();
  if (TNRS_CACHE.has(key)) return TNRS_CACHE.get(key);
  setNet("resolving…");
  try{
    const j = await fetchJSON(TNRS_URL, {}, { names:[name], do_approximate_matching:true });
    const tax = j?.results?.[0]?.matches?.[0]?.taxon;
    const out = (tax?.ott_id && tax?.name) ? { ott: tax.ott_id, sci: tax.name } : null;
    TNRS_CACHE.set(key, out);
    return out;
  } finally {
    setNet("idle");
  }
}

async function vernacularEN(ott){
  if (VERN_CACHE.has(ott)) return VERN_CACHE.get(ott);
  setNet("vernacular…");
  try{
    const j = await fetchJSON(`${OZ_VERNACULAR_URL}?ott=${ott}&lang=en`);
    const k = Object.keys(j)[0];
    const out = (k && j[k]) ? j[k] : null;
    VERN_CACHE.set(ott, out);
    return out;
  } finally {
    setNet("idle");
  }
}

/* --------------------------
   Induced subtree (id labels)
--------------------------- */
async function inducedSubtree(ottIds){
  setNet("tree…");
  try{
    const j = await fetchJSON(INDUCED_URL, {}, { ott_ids: ottIds, label_format: "id" }); // faster
    return j?.newick || null;
  } finally {
    setNet("idle");
  }
}

/* --------------------------
   Newick parser (minimal)
--------------------------- */
function parseNewick(s){
  let i = 0;
  function skipWS(){ while(/\s/.test(s[i])) i++; }
  function parseLabel(){
    skipWS(); let lab = "";
    while(i < s.length && !/[(),:;]/.test(s[i])) lab += s[i++];
    return lab.trim() || null;
  }
  function parseNode(){
    skipWS();
    let node = {};
    if(s[i] === "("){
      i++; node.children = [];
      while(true){
        node.children.push(parseNode());
        skipWS();
        if(s[i] === ","){ i++; continue; }
        if(s[i] === ")"){ i++; break; }
        break;
      }
      skipWS();
      const maybe = parseLabel();
      if(maybe) node.label = maybe;
    } else {
      const lab = parseLabel();
      if(lab) node.label = lab;
    }
    skipWS();
    if(s[i] === ":"){ i++; while(i<s.length && !/[),;]/.test(s[i])) i++; }
    return node;
  }
  return parseNode();
}

// labels are just numbers with "ott" prefix or raw IDs depending on API; handle both
function labelToOtt(label){
  if(!label) return null;
  // examples: "ott417950" or "417950"
  const m = label.match(/(?:ott)?(\d+)/i);
  return m ? parseInt(m[1],10) : null;
}

/* --------------------------
   D3 rendering
--------------------------- */
const svg = d3.select("#tree");
const g = svg.append("g");
const linksG = g.append("g").attr("class","links");
const nodesG = g.append("g").attr("class","nodes");
const zoom = d3.zoom().scaleExtent([0.4, 3]).on("zoom", (ev)=> g.attr("transform", ev.transform));
svg.call(zoom);

function buildHierarchy(n){
  function wrap(node){
    const children = node.children?.map(wrap) || null;
    const h = d3.hierarchy(node, d=>children);
    if(node.label){
      h.data.ott = labelToOtt(node.label);
    }
    return h;
  }
  return wrap(n);
}

function treeLayoutAndFit(root){
  const tree = d3.cluster().nodeSize([22, 140]);
  tree(root);

  const link = linksG.selectAll("path").data(root.links(), d=>d.target.data.ott||Math.random());
  link.join(
    enter => enter.append("path").attr("class","link")
      .attr("d", d=>`M${d.source.y},${d.source.x}L${d.target.y},${d.target.x}`),
    update => update.attr("d", d=>`M${d.source.y},${d.source.x}L${d.target.y},${d.target.x}`),
    exit => exit.remove()
  );

  const nodes = nodesG.selectAll("g.node").data(root.descendants(), d=>d.data.ott||d.depth+":"+d.x);
  nodes.join(
    enter => {
      const ng = enter.append("g").attr("class","node").attr("transform", d=>`translate(${d.y},${d.x})`);
      const leaf = ng.filter(d=>!d.children).classed("leaf", true);
      ng.filter(d=>d.children).append("circle").attr("r",2);
      leaf.append("text").attr("class","label").attr("x", 6).text(d=>{
        const isTarget = (d.data.ott === TARGET?.ott);
        return isTarget ? "?" : (OTT2SCI.get(d.data.ott) || "");
      }).classed("target", d=>d.data.ott===TARGET?.ott);
      leaf.append("text").attr("class","hint").attr("x", 6).attr("dy","1.1em").text(d=>{
        const isTarget = (d.data.ott === TARGET?.ott);
        if(isTarget) return "";
        return OTT2COMMON.get(d.data.ott) || "";
      });
      return ng;
    },
    update => update.attr("transform", d=>`translate(${d.y},${d.x})`)
      .select("text.label").text(d=>{
        const isTarget = (d.data.ott === TARGET?.ott);
        return isTarget ? "?" : (OTT2SCI.get(d.data.ott) || "");
      }),
    exit => exit.remove()
  );

  // Fit view to content
  const all = root.descendants();
  const minX = d3.min(all, d=>d.x), maxX = d3.max(all, d=>d.x);
  const minY = d3.min(all, d=>d.y), maxY = d3.max(all, d=>d.y);
  const w = svg.node().clientWidth, h = svg.node().clientHeight;
  const pad = 24;
  const dx = (maxX - minX) || 1, dy = (maxY - minY) || 1;
  const sx = (h - 2*pad) / dx, sy = (w - 2*pad) / dy;
  const s = Math.max(0.4, Math.min(2.5, Math.min(sx, sy)));
  const tx = (w - s*(minY+maxY))/2;
  const ty = (h - s*(minX+maxX))/2;
  svg.transition().duration(400).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
}

/* --------------------------
   Tooltip (optional hover)
--------------------------- */
const tip = document.getElementById("tooltip");
function showTip(html, x, y){ tip.innerHTML = html; tip.style.left = (x+12)+"px"; tip.style.top = (y+12)+"px"; tip.style.opacity = 1; }
function hideTip(){ tip.style.opacity = 0; }

/* --------------------------
   Game flow
--------------------------- */
function pickRandom(){ return LIST[Math.floor(Math.random()*LIST.length)]?.sci || "Opisthocomus hoazin"; }

async function resolveOne(name){
  const tn = await tnrsResolve(name);
  if(!tn) return null;
  // cache sci + ott
  OTT2SCI.set(tn.ott, tn.sci);
  return { sci: tn.sci, ott: tn.ott, common: null }; // common added lazily
}

function bumpTurn(){ setTurns(turns+1); }

async function startNewGame(){
  setHint("choosing…");
  setTurns(0);
  GUESSES = [];
  el("status").style.display = "none";
  el("guess").value = ""; el("guess").focus();

  // Resolve target (with retries)
  let t = null;
  for(let k=0;k<8 && !t;k++){
    t = await resolveOne(pickRandom());
  }
  if(!t){ t = await resolveOne("Opisthocomus hoazin"); }
  TARGET = t;
  setHint(OTT2SCI.get(TARGET.ott));

  // kick off vernacular fetch in background (doesn't block)
  vernacularEN(TARGET.ott).then(v=>{ if(v){ OTT2COMMON.set(TARGET.ott, v); } renderCurrentTree(); });

  renderCurrentTree(); // initial "?"
}

async function submitGuess(){
  const raw = el("guess").value.trim();
  if(!raw) return;

  // Resolve guess quickly (TNRS only; no vernacular yet)
  const resolved = await resolveOne(raw);
  if(!resolved){ bumpTurn(); return; }

  // ignore duplicate guesses
  if(GUESSES.some(g=>g.ott===resolved.ott)){ el("guess").value=""; el("guess").focus(); return; }

  GUESSES.push(resolved);
  bumpTurn();

  // Target found
  if(resolved.ott === TARGET.ott){
    renderCurrentTree();
    const box = el("status");
    box.style.display = "block";
    box.innerHTML = `<div class="good">You found it in ${turns} turn${turns===1?"":"s"} 🎉</div>
      <div><strong>Target:</strong> ${OTT2COMMON.get(TARGET.ott) ? OTT2COMMON.get(TARGET.ott)+" — " : ""}<span class="mono">${OTT2SCI.get(TARGET.ott)}</span> (OTT ${TARGET.ott})</div>`;
    el("guess").value=""; el("guess").focus(); 
    // lazily fetch vernacular for the guessed one too
    vernacularEN(resolved.ott).then(v=>{ if(v){ OTT2COMMON.set(resolved.ott, v); renderCurrentTree(); } });
    return;
  }

  // Render current partial tree; vernaculars fetched in background (non-blocking)
  renderCurrentTree();
  vernacularEN(resolved.ott).then(v=>{ if(v){ OTT2COMMON.set(resolved.ott, v); renderCurrentTree(); } });

  el("guess").value=""; el("guess").focus();
}

/* --------------------------
   Build + render the partial tree
--------------------------- */
async function renderCurrentTree(){
  // If no guesses yet, draw a single "?"
  if(GUESSES.length === 0){
    linksG.selectAll("*").remove(); nodesG.selectAll("*").remove();
    const w = svg.node().clientWidth, h = svg.node().clientHeight;
    const ng = nodesG.append("g").attr("class","leaf").attr("transform", `translate(${w/2-30},${h/2})`);
    ng.append("text").attr("class","label target").text("?").attr("font-size","20px");
    svg.call(zoom.transform, d3.zoomIdentity);
    return;
  }

  const otts = [TARGET.ott, ...GUESSES.map(g=>g.ott)];
  let newick = null;
  try{
    document.body.classList.add("busy");
    newick = await inducedSubtree(otts);
  } catch(e){
    document.body.classList.remove("busy");
    console.warn("induced_subtree failed:", e);
    // Soft error: show a toast-ish status
    const box = el("status");
    box.style.display = "block";
    box.innerHTML = `<div class="bad">Network issue fetching subtree. Try the same guess again.</div>`;
    return;
  } finally {
    document.body.classList.remove("busy");
  }
  if(!newick) return;

  // Parse & render
  const parsed = parseNewick(newick);
  const root = buildHierarchy(parsed);

  // Hover tips for guessed leaves only (target just shows "Target")
  nodesG.on("mousemove", (ev)=>{
    const d = d3.select(ev.target.parentNode).datum();
    if(!d || d.children) return hideTip();
    const isTarget = (d.data.ott === TARGET?.ott);
    if(isTarget){ showTip("<b>Target</b>", ev.clientX, ev.clientY); return; }
    const sci = OTT2SCI.get(d.data.ott) || "";
    const common = OTT2COMMON.get(d.data.ott);
    showTip(`<b>${sci}</b>${common ? " — <i>"+common+"</i>" : ""}`, ev.clientX, ev.clientY);
  }).on("mouseleave", hideTip);

  treeLayoutAndFit(root);
}

/* --------------------------
   Wire up UI + boot
--------------------------- */
document.getElementById("submit").addEventListener("click", submitGuess);
document.getElementById("guess").addEventListener("keydown", e=>{ if(e.key==="Enter") submitGuess(); });
document.getElementById("newgame").addEventListener("click", startNewGame);

loadTxtList().then(startNewGame);
</script>
</body>
</html>
