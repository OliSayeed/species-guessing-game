<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Species Guessing Game â€” Simple Distance Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --card:#fff; --ink:#111; --muted:#666; --line:#e5e7eb; --good:#0a7d25; --bad:#a60d0d; }
    html,body{margin:0;padding:0;background:#fafafa;color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:840px;margin:28px auto;padding:0 16px;}
    h1{margin:0 0 4px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:12px}
    input[type=text]{flex:1;min-width:260px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:16px}
    button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:white;cursor:pointer}
    button:hover{background:#f3f4f6}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#fff}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .good{color:var(--good);font-weight:700}
    .bad{color:var(--bad);font-weight:700}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .section{margin-top:18px}
    .list{display:flex;flex-direction:column;gap:8px}
    .small{font-size:14px}
    .footer{margin-top:28px;color:var(--muted);font-size:14px}
    .chip{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:2px 8px;margin-left:6px;font-size:12px;color:#444}
    .net{font-size:12px;color:#555}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Species Guessing Game</h1>
  <p class="muted">After each guess I show the taxonomy-tree <em>distance</em> to the secret target (smaller = closer). Distance 0 = correct ðŸŽ¯</p>

  <div class="row">
    <button id="newgame">New game</button>
    <span id="turns" class="pill">turns: 0</span>
    <span id="hint" class="pill small"></span>
    <span id="net" class="net">idle</span>
  </div>

  <div class="row">
    <input id="guess" type="text" list="names" placeholder="Type a scientific or common name" autocomplete="off" />
    <datalist id="names"></datalist>
    <button id="submit">Guess</button>
  </div>

  <div id="status" class="card section" style="display:none;"></div>

  <div class="section">
    <h3>Closest so far</h3>
    <div id="closest" class="card small">None yet â€” make a guess.</div>
  </div>

  <div class="section">
    <h3>All guesses</h3>
    <div id="log" class="list"></div>
  </div>

  <div class="footer">Uses OpenTree TNRS + Taxonomy (lineages). No big tree downloads.</div>
</div>

<script>
/* --------------------------
   Config
--------------------------- */
const OT = "https://api.opentreeoflife.org/v3";
const TNRS = `${OT}/tnrs/match_names`;
const TAXON_INFO = `${OT}/taxonomy/taxon_info`;
const TXT_PATH = "extracted_species.txt"; // optional; used only for the datalist

const NET = document.getElementById("net");
function net(s){ NET.textContent = s; }

/* --------------------------
   Net helper (timeout + retries)
--------------------------- */
const TIMEOUT = 9000, RETRIES = 2;
async function fetchJSON(url, body=null){
  const attempt = async ()=>{
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), TIMEOUT);
    try{
      const resp = await fetch(url,{
        method: body ? "POST":"GET",
        headers: body ? {"Content-Type":"application/json"} : undefined,
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
        cache: "no-store",
        mode: "cors",
      });
      if(!resp.ok) throw new Error("HTTP "+resp.status);
      return await resp.json();
    } finally { clearTimeout(t); }
  };
  let err;
  for(let k=0;k<=RETRIES;k++){
    try{ return await attempt(); }catch(e){ err=e; }
  }
  throw err;
}

/* --------------------------
   Caches
--------------------------- */
const TNRS_CACHE = new Map();     // key: nameLower -> {ott,sci} or null
const LINEAGE_CACHE = new Map();  // key: ott -> [{name,ott}, tipâ†’root]
const COMMON_CACHE = new Map();   // key: sci(lower) -> best-known common (from TNRS synonym field if exposed)

/* --------------------------
   Helpers
--------------------------- */
async function tnrs(name){
  const key = name.toLowerCase();
  if (TNRS_CACHE.has(key)) return TNRS_CACHE.get(key);
  net("resolvingâ€¦");
  try{
    const j = await fetchJSON(TNRS, { names:[name], do_approximate_matching:true });
    const t = j?.results?.[0]?.matches?.[0]?.taxon;
    if (!t?.ott_id || !t?.name){ TNRS_CACHE.set(key,null); return null; }
    const out = { ott: t.ott_id, sci: t.name };
    TNRS_CACHE.set(key, out);
    return out;
  } finally { net("idle"); }
}

async function lineage(ott){
  if (LINEAGE_CACHE.has(ott)) return LINEAGE_CACHE.get(ott);
  net("lineageâ€¦");
  try{
    const j = await fetchJSON(TAXON_INFO, { ott_id: ott, include_lineage: true });
    // normalize to tipâ†’root, drop true roots
    let arr = Array.isArray(j.lineage) ? j.lineage.slice() : [];
    // If first entry looks like root, reverse
    if (arr.length && (arr[0].ott_id===805080 || (arr[0].name||"").toLowerCase()==="life")) arr = arr.reverse();
    const clean = arr.filter(a=>{
      const nm = (a.name||"").toLowerCase();
      return a.ott_id !== 805080 && nm !== "life" && nm !== "cellular organisms";
    }).map(a => ({name: a.name||"", ott: a.ott_id||null}));
    LINEAGE_CACHE.set(ott, clean);
    return clean;
  } finally { net("idle"); }
}

// taxonomy distance via lineage intersection (nearest shared ancestor)
async function taxonomyDistance(ottA, ottB){
  if (ottA===ottB) return 0;
  const la = await lineage(ottA);
  const lb = await lineage(ottB);
  if (!la.length || !lb.length) return Infinity;

  const posB = new Map(); // ott -> index (steps from A tip/root orientation handled by clean)
  for (let i=0;i<lb.length;i++) if (lb[i].ott) posB.set(lb[i].ott, i);

  // la and lb are tipâ†’root without root; index is steps upward from tip
  for (let i=0;i<la.length;i++){
    const id = la[i].ott;
    if (id && posB.has(id)){
      const j = posB.get(id);
      return i + j; // i steps from A to shared, j from B to shared
    }
  }
  return Infinity;
}

/* --------------------------
   UI helpers
--------------------------- */
function el(id){ return document.getElementById(id); }
function setTurns(n){ el("turns").textContent = `turns: ${n}`; }
function getTurns(){ return Number(el("turns").textContent.replace(/[^\d]/g,""))||0; }
function setHint(t){ el("hint").textContent = t || ""; }
function showStatus(html, kind="bad"){
  const box = el("status");
  box.style.display = "block";
  box.innerHTML = `<div class="${kind}">${html}</div>`;
}
function clearStatus(){ el("status").style.display = "none"; }

/* --------------------------
   Datalist (optional)
--------------------------- */
async function loadNamesFile(){
  try{
    const r = await fetch(TXT_PATH, {cache:"no-store"});
    if (!r.ok) return;
    const text = await r.text();
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const genus = /[A-Z][a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
    const epithet = /(?:Ã—\s*)?[a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
    const re = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
    const names = lines.filter(s=>re.test(s)).slice(0,2500);
    const dl = el("names");
    for (const n of names){ const o=document.createElement("option"); o.value=n; dl.appendChild(o); }
  }catch{}
}

/* --------------------------
   Game state
--------------------------- */
let TARGET=null;   // {ott, sci}
let GUESSES=[];    // [{ott, sci, dist}]
function fmtSpecies(sci){ return sci; } // keep it simple for now

async function pickRandomTarget(){
  // sample a few random names from the optional list or fallback
  const fallback = ["Opisthocomus hoazin","Loxodonta africana","Zea mays","Iguana iguana","Pan troglodytes","Gadus morhua"];
  let name = fallback[Math.floor(Math.random()*fallback.length)];
  try{
    const r = await fetch(TXT_PATH, {cache:"no-store"});
    if (r.ok){
      const txt = await r.text();
      const arr = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      const genus = /[A-Z][a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
      const epithet = /(?:Ã—\s*)?[a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
      const re = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
      const valids = arr.filter(s=>re.test(s));
      if (valids.length) name = valids[Math.floor(Math.random()*valids.length)];
    }
  }catch{}
  const t = await tnrs(name);
  return t || await tnrs("Opisthocomus hoazin");
}

async function newGame(){
  setTurns(0); GUESSES = []; clearStatus();
  TARGET = await pickRandomTarget();
  setHint(TARGET?.sci || "");
  el("closest").textContent = "None yet â€” make a guess.";
  el("log").innerHTML = "";
  el("guess").value = ""; el("guess").focus();
}

/* --------------------------
   Actions
--------------------------- */
async function submitGuess(){
  const raw = el("guess").value.trim();
  if (!raw) return;
  clearStatus();
  setTurns(getTurns()+1);

  const t = await tnrs(raw);
  if (!t){
    showStatus(`Not recognized: <span class="mono">${raw}</span>`, "bad");
    el("guess").value = ""; el("guess").focus(); return;
  }

  // ignore duplicates
  if (GUESSES.some(g=>g.ott===t.ott)){ el("guess").value=""; el("guess").focus(); return; }

  const d = await taxonomyDistance(t.ott, TARGET.ott);
  GUESSES.push({ ott:t.ott, sci:t.sci, dist:d });

  // Win?
  if (d === 0){
    el("closest").innerHTML = `<div><strong>${fmtSpecies(t.sci)}</strong></div>
      <div>distance to target: <span class="mono">0</span></div>`;
    const box = el("status");
    box.style.display = "block";
    box.innerHTML = `<div class="good">You found it in ${getTurns()} turn${getTurns()===1?"":"s"} ðŸŽ‰</div>
      <div><strong>Target:</strong> <span class="mono">${TARGET.sci}</span></div>`;
    el("guess").value = ""; el("guess").focus(); return;
  }

  // Update â€œclosest so farâ€
  const best = GUESSES.reduce((a,b)=> a.dist<=b.dist ? a : b);
  el("closest").innerHTML = `
    <div><strong>${fmtSpecies(best.sci)}</strong></div>
    <div>distance to target: <span class="mono">${best.dist}</span></div>
  `;

  // Log
  const row = document.createElement("div");
  row.className = "card small";
  row.innerHTML = `<div><strong>${fmtSpecies(t.sci)}</strong></div>
                   <div>distance: <span class="mono">${d}</span></div>`;
  el("log").prepend(row);

  el("guess").value = ""; el("guess").focus();
}

/* --------------------------
   Boot
--------------------------- */
document.getElementById("submit").addEventListener("click", ()=>submitGuess().catch(e=>showStatus("Network hiccup â€” try again", "bad")));
document.getElementById("guess").addEventListener("keydown", e=>{ if (e.key==="Enter") submitGuess().catch(()=>{}); });
document.getElementById("newgame").addEventListener("click", ()=>newGame().catch(()=>{}));
loadNamesFile().then(newGame);
</script>
</body>
</html>
