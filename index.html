<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Species Guessing Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --card:#fff; --ink:#111; --muted:#666; --line:#e5e7eb; --good:#0a7d25; --bad:#a60d0d; }
    html,body{margin:0;padding:0;background:#fafafa;color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:900px;margin:32px auto;padding:0 16px;}
    h1{margin:0 0 6px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{flex:1;min-width:280px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:16px}
    button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:white;cursor:pointer}
    button:hover{background:#f3f4f6}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#fff}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .good{color:var(--good);font-weight:700}
    .bad{color:var(--bad);font-weight:700}
    .small{font-size:14px}
    .list{display:flex;flex-direction:column-reverse;gap:10px}
    .section{margin-top:18px}
    .sr{position:absolute;left:-9999px}
    .footer{margin-top:28px;color:var(--muted);font-size:14px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Species Guessing Game</h1>
  <p class="muted">Guess any species (scientific works best). I’ll reveal the <em>MRCA</em> with the secret target to guide you.</p>

  <div class="row section">
    <button id="newgame">New game</button>
    <span id="turns" class="pill">turns: 0</span>
    <span id="pool" class="pill small">pool: …</span>
    <span id="hint" class="pill small"></span>
  </div>

  <div class="row section">
    <label class="sr" for="guess">Your guess</label>
    <input id="guess" type="text" list="seednames" placeholder="e.g., Opisthocomus hoazin" />
    <datalist id="seednames"></datalist>
    <button id="submit">Guess</button>
  </div>

  <div id="status" class="card section" style="display:none;"></div>

  <div class="section">
    <h3>History</h3>
    <div id="log" class="list"></div>
  </div>

  <div class="footer">Powered by OpenTree (TNRS + MRCA) and OneZoom (vernaculars). All client-side.</div>
</div>

<script>
  // -------------------------------
  // Config (OpenTree + OneZoom)
  // -------------------------------
  const OT_BASE = "https://api.opentreeoflife.org/v3";
  const TNRS_URL = `${OT_BASE}/tnrs/match_names`;
  const MRCA_URL = `${OT_BASE}/tree_of_life/mrca`;
  const NODE_INFO_URL = `${OT_BASE}/tree_of_life/node_info`;
  const TAXON_INFO_URL = `${OT_BASE}/taxonomy/taxon_info`;
  const OZ_VERNACULAR_URL = "https://api.onezoom.org/vernacular_names.json"; // ?ott=<id>&lang=en

  // Big list (one scientific name per line)
  const TXT_PATH = "extracted_species.txt";

  // -------------------------------
  // Minimal seed (fallbacks + some common names)
  // -------------------------------
  const SEED = [
    {ott:770315, sci:"Orycteropus afer", common:"Aardvark"},
    {ott:770309, sci:"Loxodonta africana", common:"African elephant"},
    {ott:770311, sci:"Elephas maximus", common:"Asian elephant"},
    {ott:292466, sci:"Opisthocomus hoazin", common:"Hoatzin"},
    {ott:144183, sci:"Corvus corax", common:"Common raven"},
    {ott:412129, sci:"Zea mays", common:"Maize"},
    {ott:1016910,sci:"Lucanus cervus", common:"European stag beetle"}
  ];

  const NAME2OTT = new Map();
  const OTT2ROW = new Map();
  for (const s of SEED) {
    NAME2OTT.set(s.sci.toLowerCase(), s.ott);
    if (s.common) NAME2OTT.set(s.common.toLowerCase(), s.ott);
    OTT2ROW.set(s.ott, s);
  }

  // -------------------------------
  // Load the big text list
  // -------------------------------
  let LIST = []; // [{sci, ott:null, common:null}]
  async function loadTxtList() {
    try {
      const r = await fetch(TXT_PATH, {cache:"no-store"});
      if (!r.ok) throw new Error("not found");
      const text = await r.text();
      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      const genus = /[A-Z][a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
      const epithet = /(?:×\s*)?[a-zà-öø-ÿ][A-Za-zÀ-ÖØ-öø-ÿ\-]*/.source;
      const sciRe = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
      const seen = new Set();
      LIST = lines.filter(s => sciRe.test(s)).filter(s => {
        const k = s.toLowerCase(); if (seen.has(k)) return false; seen.add(k); return true;
      }).map(s => ({sci:s, ott:null, common:null}));
      setPool(LIST.length);
      addToDatalist();
    } catch {
      setPool(SEED.length);
    }
  }

  // -------------------------------
  // OpenTree / OneZoom helpers
  // -------------------------------
  async function tnrsResolve(name) {
    try {
      const r = await fetch(TNRS_URL, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ names:[name], do_approximate_matching:true })
      });
      if (!r.ok) return null;
      const j = await r.json();
      const tax = j?.results?.[0]?.matches?.[0]?.taxon;
      if (!tax?.ott_id || !tax?.name) return null;
      return { ott: tax.ott_id, sci: tax.name, rank: tax.rank || null };
    } catch { return null; }
  }

  async function fetchNodeInfo(node_id, include_lineage=false) {
    try {
      const r = await fetch(NODE_INFO_URL, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ node_id, include_lineage })
      });
      if (!r.ok) return null;
      return await r.json();
    } catch { return null; }
  }

  // Normalize lineage orientation to NEAREST-FIRST (tip→root)
  function toNearestFirst(lineageArr){
    const arr = Array.isArray(lineageArr) ? lineageArr.slice() : [];
    if (!arr.length) return [];
    const firstName = (arr[0].name || arr[0].unique_name || "").toLowerCase();
    const firstOtt = arr[0].ott_id || null;
    const looksRootFirst = firstOtt === 805080 || firstName === "life" || firstName === "cellular organisms";
    const out = looksRootFirst ? arr.reverse() : arr;
    // strip true roots
    return out.filter(a => {
      const nm = (a.name || a.unique_name || "").toLowerCase();
      const id = a.ott_id || null;
      if (id === 805080) return false; // life
      if (nm === "life" || nm === "cellular organisms") return false;
      return true;
    });
  }

  // Taxonomy lineage for a tip → nearest-first, with {name, ott}
  async function taxonomyLineage(ott) {
    try {
      const r = await fetch(TAXON_INFO_URL, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ ott_id: ott, include_lineage: true })
      });
      if (!r.ok) return [];
      const j = await r.json();
      const nf = toNearestFirst(j.lineage || []);
      return nf.map(a => ({ name: a.name || a.unique_name, ott: a.ott_id || null }));
    } catch { return []; }
  }

  // Fallback MRCA via taxonomy: deepest shared **ancestor by OTT id**
  async function mrcaByTaxonomy(ottA, ottB) {
    const la = await taxonomyLineage(ottA);
    const lb = await taxonomyLineage(ottB);
    if (!la.length || !lb.length) return { label: "unknown", ott: null, tips: null };
    const setB = new Set(lb.map(n => n.ott).filter(Boolean));
    for (const n of la) {
      if (n.ott && setB.has(n.ott)) {
        return { label: n.name, ott: n.ott, tips: null };
      }
    }
    return { label: "unknown", ott: null, tips: null };
  }

  // Robust MRCA label: synth first, then taxonomy fallback
  async function mrcaLabeled(ottA, ottB) {
    try {
      // Synth MRCA
      const r = await fetch(MRCA_URL, {
        method:"POST", headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ ott_ids:[ottA, ottB] })
      });
      if (r.ok) {
        const node_id = (await r.json())?.node_id;
        if (node_id) {
          let info = await fetchNodeInfo(node_id, false);
          if (info) {
            const tips = info.num_tips ?? info.num_synth_tips ?? null;
            const direct = info.name || info.unique_name;
            if (direct && (direct.toLowerCase() !== "life")) {
              return { label: direct, ott: (info.ott_id ?? null), tips };
            }
            // lineage on synth
            info = await fetchNodeInfo(node_id, true);
            if (info?.lineage && info.lineage.length) {
              const nf = toNearestFirst(info.lineage);
              const nearestNamed = nf.find(a => (a.name || a.unique_name));
              if (nearestNamed) {
                const nm = nearestNamed.name || nearestNamed.unique_name;
                if (nm.toLowerCase() !== "life") {
                  return { label: nm, ott: (nearestNamed.ott_id ?? null), tips };
                }
              }
            }
          }
        }
      }
      // Fallback: taxonomy intersection
      return await mrcaByTaxonomy(ottA, ottB);
    } catch {
      return await mrcaByTaxonomy(ottA, ottB);
    }
  }

  async function getVernacularEN(ott){
    try {
      const r = await fetch(`${OZ_VERNACULAR_URL}?ott=${ott}&lang=en`, {cache:"no-store"});
      if (!r.ok) return null;
      const j = await r.json();
      const k = Object.keys(j)[0];
      return (k && j[k]) ? j[k] : null;
    } catch { return null; }
  }

  // -------------------------------
  // UI helpers
  // -------------------------------
  function el(id){ return document.getElementById(id); }
  function setTurns(n){ el("turns").textContent = `turns: ${n}`; }
  function setPool(n){ el("pool").textContent = `pool: ${n}`; }
  function setHint(t){ el("hint").textContent = t || ""; }
  function clearLog(){ el("log").innerHTML = ""; }
  function addLog(entry){
    const box = document.createElement("div");
    box.className = "card small";
    if (!entry.resolved) {
      box.innerHTML = `<div><strong>Guess:</strong> ${entry.raw}</div><div class="bad">Not recognized.</div>`;
    } else if (entry.correct) {
      box.innerHTML = `<div><strong>Guess:</strong> ${entry.raw}</div>
        <div>Resolved: <span class="mono">${entry.guess_name}</span> (OTT ${entry.guess_ott})</div>
        <div class="good">Correct! 🎉</div>`;
    } else {
      const tips = entry.mrca_tips != null ? ` • clade size: ${entry.mrca_tips}` : "";
      box.innerHTML = `<div><strong>Guess:</strong> ${entry.raw}</div>
        <div>Resolved: <span class="mono">${entry.guess_name}</span> (OTT ${entry.guess_ott})</div>
        <div>MRCA: <span class="mono">${entry.mrca_label}${entry.mrca_ott ? ` (OTT ${entry.mrca_ott})` : ""}</span>${tips}</div>`;
    }
    el("log").prepend(box);
  }

  function showStatusFound(sp, turns){
    const t = el("status");
    t.style.display = "block";
    t.innerHTML = `<div class="good">You found it in ${turns} turn${turns===1?"":"s"}.</div>
      <div><strong>Target:</strong> ${sp.common ? `${sp.common} — ` : ""}<span class="mono">${sp.sci}</span> • OTT ${sp.ott}</div>`;
  }

  function addToDatalist(){
    const dl = el("seednames");
    dl.innerHTML = "";
    const sample = LIST.slice(0, 1500);
    for (const s of sample) {
      const o = document.createElement("option"); o.value = s.sci; dl.appendChild(o);
    }
    for (const s of SEED) {
      if (s.common) { const o = document.createElement("option"); o.value = s.common; dl.appendChild(o); }
    }
  }

  // -------------------------------
  // Game state
  // -------------------------------
  let target = null; // {sci, ott, common}
  let turns = 0;

  function pickRandomFromList(){
    if (!LIST.length) return SEED[Math.floor(Math.random()*SEED.length)];
    const i = Math.floor(Math.random()*LIST.length);
    return {...LIST[i]};
  }

  async function ensureResolved(sp){
    if (!sp || sp.ott) return sp;
    const r = await tnrsResolve(sp.sci);
    if (!r || !r.ott) return sp;
    sp.ott = r.ott;
    sp.sci = r.sci;
    const vn = await getVernacularEN(sp.ott);
    if (vn) sp.common = vn;
    return sp;
  }

  async function newGame(){
    setHint("choosing…");
    target = pickRandomFromList();
    for (let k=0;k<8 && (!target.ott);k++){
      target = await ensureResolved(target);
      if (!target.ott) target = pickRandomFromList();
    }
    if (!target.ott) {
      target = SEED[Math.floor(Math.random()*SEED.length)];
      setHint("(fallback target)");
    } else {
      setHint(target.common ? target.common : target.sci);
    }
    turns = 0; setTurns(turns);
    clearLog();
    el("status").style.display = "none";
    el("guess").value = ""; el("guess").focus();
  }

  async function submitGuess(){
    if (!target) return;
    const raw = el("guess").value.trim();
    if (!raw) return;

    let guessOtt = NAME2OTT.get(raw.toLowerCase());
    let guessName = null;

    if (guessOtt) {
      guessName = OTT2ROW.get(guessOtt)?.sci || raw;
    } else {
      const tnrs = await tnrsResolve(raw);
      if (!tnrs) {
        turns++; setTurns(turns); addLog({ raw, resolved:false });
        el("guess").value = ""; el("guess").focus(); return;
      }
      guessOtt = tnrs.ott; guessName = tnrs.sci;
    }

    turns++; setTurns(turns);

    if (guessOtt === target.ott) {
      addLog({ raw, resolved:true, correct:true, guess_ott:guessOtt, guess_name:guessName });
      showStatusFound(target, turns);
      el("guess").value = ""; el("guess").focus(); return;
    }

    const m = await mrcaLabeled(target.ott, guessOtt);
    addLog({
      raw, resolved:true, correct:false,
      guess_ott:guessOtt, guess_name:guessName,
      mrca_label:m.label, mrca_ott:m.ott, mrca_tips:m.tips
    });
    el("guess").value = ""; el("guess").focus();
  }

  // Wire up UI + boot
  document.getElementById("newgame").addEventListener("click", newGame);
  document.getElementById("submit").addEventListener("click", submitGuess);
  document.getElementById("guess").addEventListener("keydown", e=>{ if (e.key==="Enter") submitGuess(); });

  loadTxtList().then(newGame);
</script>
</body>
</html>
