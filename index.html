<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Species Guessing Game â€” Simple Mode + Common Names</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --card:#fff; --ink:#111; --muted:#666; --line:#e5e7eb; --good:#0a7d25; --bad:#a60d0d; }
    html,body{margin:0;padding:0;background:#fafafa;color:var(--ink);font:16px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:840px;margin:28px auto;padding:0 16px;}
    h1{margin:0 0 4px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:12px}
    input[type=text]{flex:1;min-width:260px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:16px}
    button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:white;cursor:pointer}
    button:hover{background:#f3f4f6}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#fff}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .good{color:var(--good);font-weight:700}
    .bad{color:var(--bad);font-weight:700}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .section{margin-top:18px}
    .list{display:flex;flex-direction:column;gap:8px}
    .small{font-size:14px}
    .footer{margin-top:28px;color:var(--muted);font-size:14px}
    .chip{display:inline-block;border:1px solid var(--line);border-radius:999px;padding:2px 8px;margin-left:6px;font-size:12px;color:#444}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Species Guessing Game</h1>
  <p class="muted">After each guess I show the taxonomy-tree <em>distance</em> to the secret target (smaller = closer). You can type either a scientific or a common name. Distance 0 = correct ðŸŽ¯</p>

  <div class="row">
    <button id="newgame">New game</button>
    <span id="turns" class="pill">turns: 0</span>
    <span id="hint" class="pill small"></span>
  </div>

  <div class="row">
    <input id="guess" type="text" list="names" placeholder="Type a scientific or common name" autocomplete="off" />
    <datalist id="names"></datalist>
    <button id="submit">Guess</button>
  </div>

  <div id="status" class="card section" style="display:none;"></div>

  <div class="section">
    <h3>Closest so far</h3>
    <div id="closest" class="card small">None yet â€” make a guess.</div>
  </div>

  <div class="section">
    <h3>All guesses</h3>
    <div id="log" class="list"></div>
  </div>

  <div class="footer">Uses OpenTree TNRS + Taxonomy (lineages). Optional GBIF precompute for common names.</div>
</div>

<script>
/* --------------------------
   Config
--------------------------- */
const OT = "https://api.opentreeoflife.org/v3";
const TNRS = `${OT}/tnrs/match_names`;
const TAXON_INFO = `${OT}/taxonomy/taxon_info`;
const TXT_PATH = "extracted_species.txt";      // optional; datalist
const CN_PATH  = "common_names.json";          // from precompute_common.html

/* --------------------------
   Net helper (timeout+retries)
--------------------------- */
const TIMEOUT = 9000, RETRIES = 2;
async function fetchJSON(url, body=null){
  const attempt = async ()=>{
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), TIMEOUT);
    try{
      const resp = await fetch(url,{
        method: body ? "POST":"GET",
        headers: body ? {"Content-Type":"application/json"} : undefined,
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
        cache: "no-store",
        mode: "cors",
      });
      if(!resp.ok) throw new Error("HTTP "+resp.status);
      return await resp.json();
    } finally { clearTimeout(t); }
  };
  let err;
  for(let k=0;k<=RETRIES;k++){
    try{ return await attempt(); }catch(e){ err=e; }
  }
  throw err;
}

/* --------------------------
   Caches + maps
--------------------------- */
const TNRS_CACHE = new Map();     // nameLower -> {ott,sci} or null
const LINEAGE_CACHE = new Map();  // ott -> [{name,ott}] tipâ†’root
const COMMON_BY_SCI = new Map();  // sci(lower) -> common
const COMMON_BY_COMMON = new Map();// common(lower) -> common (self)
const SUGGEST_NAMES = [];         // for datalist (sci + common)

/* --------------------------
   Load common_names.json (optional)
--------------------------- */
async function loadCommon(){
  try{
    const j = await fetchJSON(CN_PATH);
    if (!j || !Array.isArray(j.entries)) return;
    for (const e of j.entries){
      if (!e || !e.sci) continue;
      const sciLower = e.sci.toLowerCase();
      if (e.common){
        COMMON_BY_SCI.set(sciLower, e.common);
        COMMON_BY_COMMON.set(e.common.toLowerCase(), e.common);
        SUGGEST_NAMES.push(e.common);
      }
      SUGGEST_NAMES.push(e.sci);
    }
  } catch {
    // No common_names.json present â€” that's fine; weâ€™ll still work with sci names.
  }
}

/* --------------------------
   TNRS + lineage helpers
--------------------------- */
async function tnrs(name){
  const key = name.toLowerCase();
  if (TNRS_CACHE.has(key)) return TNRS_CACHE.get(key);

  // If the input is a common name we know, map to scientific first
  let query = name;
  if (COMMON_BY_COMMON.has(key)){
    // find its scientific name candidate from our entries list (reverse lookup by common)
    // We donâ€™t store reverse map; just try TNRS on the common; OT usually wonâ€™t match common names,
    // so as a safer path we try to map common->sci via our COMMON_BY_SCI keys:
    // pick the first sci whose common equals this common.
    const targetCommon = COMMON_BY_COMMON.get(key);
    for (const [sciLower, cn] of COMMON_BY_SCI.entries()){
      if (cn === targetCommon){ query = sciLower; break; }
    }
  }

  try{
    const j = await fetchJSON(TNRS, { names:[query], do_approximate_matching:true });
    const t = j?.results?.[0]?.matches?.[0]?.taxon;
    if (!t?.ott_id || !t?.name){ TNRS_CACHE.set(key,null); return null; }
    const out = { ott: t.ott_id, sci: t.name };
    TNRS_CACHE.set(key, out);
    return out;
  } catch {
    TNRS_CACHE.set(key,null);
    return null;
  }
}

async function lineage(ott){
  if (LINEAGE_CACHE.has(ott)) return LINEAGE_CACHE.get(ott);
  const j = await fetchJSON(TAXON_INFO, { ott_id: ott, include_lineage: true });
  let arr = Array.isArray(j.lineage) ? j.lineage.slice() : [];
  if (arr.length && (arr[0].ott_id===805080 || (arr[0].name||"").toLowerCase()==="life")) arr = arr.reverse();
  const clean = arr.filter(a=>{
    const nm = (a.name||"").toLowerCase();
    return a.ott_id !== 805080 && nm !== "life" && nm !== "cellular organisms";
  }).map(a => ({name: a.name||"", ott: a.ott_id||null}));
  LINEAGE_CACHE.set(ott, clean);
  return clean;
}

async function taxonomyDistance(ottA, ottB){
  if (ottA===ottB) return 0;
  const la = await lineage(ottA);
  const lb = await lineage(ottB);
  if (!la.length || !lb.length) return Infinity;
  const posB = new Map();
  for (let i=0;i<lb.length;i++) if (lb[i].ott) posB.set(lb[i].ott, i);
  for (let i=0;i<la.length;i++){
    const id = la[i].ott;
    if (id && posB.has(id)) return i + posB.get(id);
  }
  return Infinity;
}

/* --------------------------
   Datalist (from file + common_names)
--------------------------- */
async function loadNamesFile(){
  try{
    const r = await fetch(TXT_PATH, {cache:"no-store"});
    if (!r.ok) return;
    const text = await r.text();
    const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const genus = /[A-Z][a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
    const epithet = /(?:Ã—\s*)?[a-zÃ -Ã¶Ã¸-Ã¿][A-Za-zÃ€-Ã–Ã˜-Ã¶Ã¸-Ã¿\-]*/.source;
    const re = new RegExp(`^${genus}\\s+${epithet}(?:\\s+${epithet}){0,2}$`);
    const names = lines.filter(s=>re.test(s));
    SUGGEST_NAMES.push(...names);
  }catch{}
}

function buildDatalist(){
  // Deduplicate, cap ~3000 for snappiness
  const seen = new Set();
  const dl = document.getElementById("names");
  dl.innerHTML = "";
  for (const n of SUGGEST_NAMES){
    const k = n.toLowerCase();
    if (seen.has(k)) continue;
    seen.add(k);
    const o=document.createElement("option"); o.value=n; dl.appendChild(o);
    if (seen.size >= 3000) break;
  }
}

/* --------------------------
   UI helpers
--------------------------- */
function el(id){ return document.getElementById(id); }
function setTurns(n){ el("turns").textContent = `turns: ${n}`; }
function getTurns(){ return Number(el("turns").textContent.replace(/[^\d]/g,""))||0; }
function setHint(t){ el("hint").textContent = t || ""; }
function resetUI(){ el("status").style.display="none"; el("guess").value=""; el("guess").focus(); }
function chipCommon(sci){
  const cn = COMMON_BY_SCI.get(sci.toLowerCase());
  return cn ? ` <span class="chip">${cn}</span>` : "";
}

/* --------------------------
   Game state
--------------------------- */
let TARGET=null;   // {ott, sci}
let GUESSES=[];    // [{ott, sci, dist}]

async function pickRandomTarget(){
  // pick from list if present; fall back to a small seed
  const fallback = ["Opisthocomus hoazin","Loxodonta africana","Zea mays","Iguana iguana","Pan troglodytes","Gadus morhua"];
  let name = fallback[Math.floor(Math.random()*fallback.length)];
  if (SUGGEST_NAMES.length){
    const onlySci = SUGGEST_NAMES.filter(s=>/^[A-Z]/.test(s)); // rough: sci names start with uppercase genus
    if (onlySci.length) name = onlySci[Math.floor(Math.random()*onlySci.length)];
  }
  const t = await tnrs(name);
  return t || await tnrs("Opisthocomus hoazin");
}

async function newGame(){
  setTurns(0); GUESSES = [];
  TARGET = await pickRandomTarget();
  setHint(TARGET?.sci + chipCommon(TARGET?.sci || "") );
  resetUI();
  el("closest").textContent = "None yet â€” make a guess.";
  el("log").innerHTML = "";
}

/* --------------------------
   Rendering
--------------------------- */
function renderClosest(){
  if (!GUESSES.length){ el("closest").textContent = "None yet â€” make a guess."; return; }
  const best = GUESSES.reduce((a,b)=> a.dist<=b.dist ? a : b);
  el("closest").innerHTML = `
    <div><strong>${best.sci}${chipCommon(best.sci)}</strong></div>
    <div>distance to target: <span class="mono">${best.dist}</span></div>
  `;
}

function renderLog(){
  const box = el("log"); box.innerHTML = "";
  for (const g of [...GUESSES].reverse()){
    const row = document.createElement("div");
    row.className = "card small";
    row.innerHTML = `
      <div><strong>${g.sci}${chipCommon(g.sci)}</strong></div>
      <div>distance: <span class="mono">${g.dist}</span></div>
    `;
    box.appendChild(row);
  }
}

/* --------------------------
   Actions
--------------------------- */
async function submitGuess(){
  const raw = el("guess").value.trim();
  if (!raw) return;

  setTurns(getTurns()+1);

  const t = await tnrs(raw);
  if (!t){
    // If they typed a common name we know, map it to sci and try again:
    const cmn = COMMON_BY_COMMON.get(raw.toLowerCase());
    if (cmn){
      const sci = [...COMMON_BY_SCI.keys()].find(k => COMMON_BY_SCI.get(k)===cmn) || null;
      if (sci){
        const t2 = await tnrs(sci);
        if (t2){ await handleResolved(t2); return; }
      }
    }
    const box = el("status");
    box.style.display = "block";
    box.innerHTML = `<div class="bad">Not recognized: <span class="mono">${raw}</span></div>`;
    resetUI();
    return;
  }
  await handleResolved(t);
}

async function handleResolved(t){
  if (GUESSES.some(g=>g.ott===t.ott)){ resetUI(); return; }
  const d = await taxonomyDistance(t.ott, TARGET.ott);
  GUESSES.push({ ott:t.ott, sci:t.sci, dist:d });

  if (d === 0){
    renderClosest();
    renderLog();
    const box = el("status");
    box.style.display = "block";
    box.innerHTML = `<div class="good">You found it in ${getTurns()} turn${getTurns()===1?"":"s"} ðŸŽ‰</div>
      <div><strong>Target:</strong> <span class="mono">${TARGET.sci}</span>${chipCommon(TARGET.sci)}</div>`;
    resetUI();
    return;
  }
  renderClosest();
  renderLog();
  resetUI();
}

/* --------------------------
   Boot
--------------------------- */
(async function(){
  await loadCommon();          // optional, but enables common names
  await loadNamesFile();       // optional datalist
  buildDatalist();
  newGame();
})();

document.getElementById("submit").addEventListener("click", ()=>submitGuess().catch(()=>{}));
document.getElementById("guess").addEventListener("keydown", e=>{ if (e.key==="Enter") submitGuess().catch(()=>{}); });
document.getElementById("newgame").addEventListener("click", ()=>newGame().catch(()=>{}));
</script>
</body>
</html>
