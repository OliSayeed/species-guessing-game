<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Species Guessing Game — Offline Partial Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root { --card:#fff; --ink:#111; --muted:#666; --line:#e5e7eb; --good:#0a7d25; --bad:#a60d0d; }
    html,body{margin:0;padding:0;background:#fafafa;color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
    .wrap{max-width:1040px;margin:24px auto;padding:0 16px;}
    h1{margin:0 0 6px}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    input[type=text]{flex:1;min-width:280px;padding:10px 12px;border:1px solid var(--line);border-radius:10px;font-size:16px}
    button{padding:10px 14px;border:1px solid var(--line);border-radius:10px;background:white;cursor:pointer}
    button:hover{background:#f3f4f6}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#fff}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px}
    .good{color:var(--good);font-weight:700}
    .bad{color:var(--bad);font-weight:700}
    .small{font-size:14px}
    .section{margin-top:16px}
    .footer{margin-top:28px;color:var(--muted);font-size:14px}
    .viswrap{background:#fff;border:1px solid var(--line);border-radius:14px;overflow:hidden}
    svg{display:block;width:100%;height:520px;background:#fff;touch-action:none}
    .link{fill:none;stroke:#cbd5e1;stroke-width:1.2px}
    .leaf text{font-size:13px;dominant-baseline:middle}
    .leaf .label{fill:#111}
    .leaf .label.target{font-weight:700}
    .leaf .hint{fill:#666;font-size:12px}
    .tooltip{position:fixed;pointer-events:none;background:#111;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .12s ease;}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Species Guessing Game</h1>
  <p class="muted">All local: we render just the part of the tree needed to compare your guesses with the secret target. Leaves show scientific names; the target is <strong>?</strong>. Hover for common names.</p>

  <div class="row section">
    <button id="newgame">New game</button>
    <span id="turns" class="pill">turns: 0</span>
    <span id="pool" class="pill small">pool: …</span>
    <span id="hint" class="pill small"></span>
  </div>

  <div class="row section">
    <input id="guess" type="text" list="namelist" placeholder="Type a scientific or common name" />
    <datalist id="namelist"></datalist>
    <button id="submit">Guess</button>
  </div>

  <div class="viswrap section">
    <svg id="tree"></svg>
  </div>

  <div id="status" class="card section" style="display:none;"></div>

  <div class="footer">Precomputed with OpenTree/OneZoom. No network during play.</div>
</div>

<div id="tooltip" class="tooltip"></div>

<script>
/* ---------- Load precomputed packs ---------- */
let PACK=null, TOPO=null;

async function loadJSON(path){ const r=await fetch(path, {cache:"no-store"}); if(!r.ok) throw new Error(path); return r.json(); }
async function bootLoad(){
  PACK = await loadJSON("species_pack.json");
  TOPO = await loadJSON("tree_topology.json");
  if (!PACK || !TOPO) throw new Error("Missing precomputed files");
}

/* ---------- Indexes & helpers ---------- */
const name2ott = new Map(); // lower name -> ott
const ott2sci = new Map();
const ott2common = new Map();

function initMaps(){
  for (const [k,v] of Object.entries(PACK.name_to_ott)) name2ott.set(k, v);
  for (const sp of PACK.species){
    ott2sci.set(sp.ott, sp.sci);
    if (sp.common){ ott2common.set(sp.ott, sp.common); name2ott.set(sp.common.toLowerCase(), sp.ott); }
  }
}

function el(id){ return document.getElementById(id); }
function setTurns(n){ el("turns").textContent = `turns: ${n}`; }
function setPool(n){ el("pool").textContent = `pool: ${n}`; }
function setHint(t){ el("hint").textContent = t || ""; }

/* ---------- LCA (binary lifting) ---------- */
let up=null, depth=null;
function buildLCA(){
  const n = TOPO.n, parent = TOPO.parent;
  depth = new Int32Array(n);
  const LOG = Math.ceil(Math.log2(Math.max(1,n)));
  up = Array.from({length:LOG+1}, ()=>new Int32Array(n).fill(-1));

  // Build children list for a BFS from root to compute depths
  const kids = Array.from({length:n}, ()=>[]);
  for (let v=0; v<n; v++){ const p = parent[v]; if (p>=0) kids[p].push(v); }
  const root = TOPO.root;
  const q = [root]; depth[root]=0; up[0][root] = -1;
  for(let qi=0; qi<q.length; qi++){
    const v = q[qi];
    for (const w of kids[v]){ depth[w] = depth[v]+1; up[0][w] = v; q.push(w); }
  }
  for(let j=1;j<up.length;j++){
    for(let v=0; v<n; v++){
      const mid = up[j-1][v];
      up[j][v] = (mid>=0 ? up[j-1][mid] : -1);
    }
  }
}
function lca(a,b){
  if (a===b) return a;
  if (depth[a] < depth[b]) [a,b] = [b,a];
  let diff = depth[a]-depth[b];
  for(let j=0; diff>0; j++, diff>>=1){ if (diff&1) a = up[j][a]; }
  if (a===b) return a;
  for(let j=up.length-1;j>=0;j--){
    if (up[j][a] !== up[j][b]){ a = up[j][a]; b = up[j][b]; }
  }
  return up[0][a];
}

/* ---------- Build minimal connecting subtree ---------- */
function pathToRoot(v){
  const p = TOPO.parent; const out = [];
  while (v>=0){ out.push(v); v = p[v]; }
  return out; // v..root
}
function minimalSubtreeFor(leafNodeIndices){
  // union of paths + all their pairwise LCAs with target
  const keep = new Set();
  const addPath = (v)=>{ while(v>=0 && !keep.has(v)){ keep.add(v); v = TOPO.parent[v]; } };
  for (const v of leafNodeIndices) addPath(v);
  // compress: build children for kept nodes with only kept children
  const children = new Map();
  for (const v of keep){
    const ch = [];
    for (let i=0;i<TOPO.n;i++){
      if (TOPO.parent[i]===v && keep.has(i)) ch.push(i);
    }
    children.set(v, ch);
  }
  // find display root = LCA of all leaves
  let root = leafNodeIndices[0];
  for (let i=1;i<leafNodeIndices.length;i++) root = lca(root, leafNodeIndices[i]);
  return { keep, children, root };
}

/* ---------- D3 drawing ---------- */
const svg = d3.select("#tree");
const g = svg.append("g");
const linksG = g.append("g").attr("class","links");
const nodesG = g.append("g").attr("class","nodes");
const zoom = d3.zoom().scaleExtent([0.4, 3]).on("zoom", (ev)=> g.attr("transform", ev.transform));
svg.call(zoom);

function buildHierarchyFromKeep(keep, children, rootIdx){
  // convert to a small hierarchy that d3.cluster can read
  const toNode = (idx)=>{
    const node = { idx, children:[] };
    const ch = children.get(idx) || [];
    node.children = ch.map(toNode);
    return node;
  };
  return d3.hierarchy(toNode(rootIdx), d=>d.children);
}

function treeLayoutAndFit(root, isTargetLeaf){
  const tree = d3.cluster().nodeSize([22, 140]);
  tree(root);

  const link = linksG.selectAll("path").data(root.links(), d=>d.target.data.idx);
  link.join(
    enter => enter.append("path").attr("class","link")
      .attr("d", d=>`M${d.source.y},${d.source.x}L${d.target.y},${d.target.x}`),
    update => update.attr("d", d=>`M${d.source.y},${d.source.x}L${d.target.y},${d.target.x}`),
    exit => exit.remove()
  );

  const nodes = nodesG.selectAll("g.node").data(root.descendants(), d=>d.data.idx);
  nodes.join(
    enter => {
      const ng = enter.append("g").attr("class","node").attr("transform", d=>`translate(${d.y},${d.x})`);
      const lc = ng.filter(d=> (childrenCount(d.data.idx)===0) ).classed("leaf", true);
      ng.filter(d=>childrenCount(d.data.idx)>0).append("circle").attr("r",2);
      lc.append("text").attr("class","label").attr("x",6).text(d=>{
        const ott = TOPO.index_ott[d.data.idx];
        if (ott === TARGET.ott) return "?";
        return ott2sci.get(ott) || "";
      }).classed("target", d=>TOPO.index_ott[d.data.idx]===TARGET.ott);
      lc.append("text").attr("class","hint").attr("x",6).attr("dy","1.1em").text(d=>{
        const ott = TOPO.index_ott[d.data.idx];
        if (ott === TARGET.ott) return "";
        return ott2common.get(ott) || "";
      });
      return ng;
    },
    update => update.attr("transform", d=>`translate(${d.y},${d.x})`)
      .select("text.label").text(d=>{
        const ott = TOPO.index_ott[d.data.idx];
        if (ott === TARGET.ott) return "?";
        return ott2sci.get(ott) || "";
      }),
    exit => exit.remove()
  );

  // Fit to content
  const all = root.descendants();
  const minX = d3.min(all, d=>d.x), maxX = d3.max(all, d=>d.x);
  const minY = d3.min(all, d=>d.y), maxY = d3.max(all, d=>d.y);
  const w = svg.node().clientWidth, h = svg.node().clientHeight;
  const pad = 24;
  const dx = (maxX - minX) || 1, dy = (maxY - minY) || 1;
  const sx = (h - 2*pad) / dx, sy = (w - 2*pad) / dy;
  const s = Math.max(0.4, Math.min(2.5, Math.min(sx, sy)));
  const tx = (w - s*(minY+maxY))/2;
  const ty = (h - s*(minX+maxX))/2;
  svg.transition().duration(400).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
}

function childrenCount(v){
  let c = 0;
  for (let i=0;i<TOPO.n;i++) if (TOPO.parent[i]===v) c++;
  return c;
}

/* ---------- Game state ---------- */
let TARGET=null;
let GUESSES=[];

function pickRandomOTT(){
  const arr = PACK.species;
  const r = arr[Math.floor(Math.random()*arr.length)];
  return r.ott;
}

function updateDatalist(){
  const dl = document.getElementById("namelist");
  dl.innerHTML = "";
  const names = [];
  for (const sp of PACK.species){ names.push(sp.sci); if (sp.common) names.push(sp.common); }
  for (const v of names.slice(0, 2000)){ const o=document.createElement("option"); o.value=v; dl.appendChild(o); }
}

function resetUI(){
  document.getElementById("status").style.display="none";
  document.getElementById("guess").value="";
  document.getElementById("guess").focus();
}

function renderInitial(){
  linksG.selectAll("*").remove(); nodesG.selectAll("*").remove();
  const w = svg.node().clientWidth, h = svg.node().clientHeight;
  const ng = nodesG.append("g").attr("class","leaf").attr("transform", `translate(${w/2-30},${h/2})`);
  ng.append("text").attr("class","label target").text("?").attr("font-size","20px");
  svg.call(d3.zoom().transform, d3.zoomIdentity);
}

function renderPartial(){
  if (GUESSES.length===0){ renderInitial(); return; }
  // node indices for leaves in play (target + all guessed)
  const indices = [];
  const targetIdx = TOPO.ott_index[String(TARGET.ott)];
  indices.push(targetIdx);
  for (const g of GUESSES){
    const idx = TOPO.ott_index[String(g.ott)];
    if (idx!=null) indices.push(idx);
  }
  // build minimal subtree
  // include LCAs pairwise with target automatically via path union
  const ms = minimalSubtreeFor(indices);
  const h = buildHierarchyFromKeep(ms.keep, ms.children, ms.root);
  treeLayoutAndFit(h);
}

/* ---------- Actions ---------- */
async function newGame(){
  setTurns(0);
  GUESSES.length = 0;
  TARGET = { ott: pickRandomOTT() };
  setHint(ott2sci.get(TARGET.ott));
  resetUI();
  renderPartial();
}

function submitGuess(){
  const raw = document.getElementById("guess").value.trim();
  if (!raw) return;
  const ott = name2ott.get(raw.toLowerCase());
  setTurns(parseInt(document.getElementById("turns").textContent.replace(/\D+/g,""))+1);
  if (!ott){ // unrecognized
    const box = document.getElementById("status");
    box.style.display = "block";
    box.innerHTML = `<div class="bad">Not recognized: <span class="mono">${raw}</span></div>`;
    resetUI();
    return;
  }
  // duplicate?
  if (GUESSES.some(g=>g.ott===ott)) { resetUI(); return; }

  GUESSES.push({ ott });
  if (ott === TARGET.ott){
    renderPartial();
    const box = document.getElementById("status");
    box.style.display = "block";
    const cn = ott2common.get(TARGET.ott);
    box.innerHTML = `<div class="good">You found it in ${document.getElementById("turns").textContent.split(": ")[1]} 🎉</div>
      <div><strong>Target:</strong> ${cn ? cn+" — " : ""}<span class="mono">${ott2sci.get(TARGET.ott)}</span> (OTT ${TARGET.ott})</div>`;
    resetUI();
    return;
  }
  renderPartial();
  resetUI();
}

/* ---------- Boot ---------- */
(async function(){
  await bootLoad();
  initMaps();
  setPool(PACK.species.length);
  updateDatalist();
  buildLCA();
  setTurns(0);
  newGame();
})();

document.getElementById("submit").addEventListener("click", submitGuess);
document.getElementById("guess").addEventListener("keydown", e=>{ if(e.key==="Enter") submitGuess(); });
document.getElementById("newgame").addEventListener("click", newGame);
</script>
</body>
</html>
